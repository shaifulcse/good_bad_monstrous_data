{
  "origin": "codeshovel",
  "repositoryName": "netty",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/netty/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "UnpooledDirectByteBuf.java",
  "functionName": "deallocate",
  "functionId": "deallocate",
  "sourceFilePath": "buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java",
  "functionStartLine": 637,
  "functionEndLine": 648,
  "numCommitsSeen": 60,
  "timeTaken": 1673,
  "changeHistory": [
    "65b522a2a75c78c977a65e15663509509b5f12e0",
    "7231be592aa65ac1e91d0a319761f7e3df2225e9",
    "764741c5ce73f42f6451027c8f87d4021deac0e1",
    "14158070bf8b3f831702061ffd657c84179fc639",
    "b9996908b1fac66526395414cc5c3a14a1567d4e",
    "337f5bbb8e12580e03274c15e90ccf702da6cc90",
    "64ae8b6a37249d099b5043ca39dc37c626e993ee",
    "a8f5efdb262bb9d55dcb71752f7cb41138ce6d7c",
    "5f9090a7f037e566c511c02eb6ae73ca2f6774cb",
    "81e2db10faaf0389f4e1af8c7132210946203157"
  ],
  "changeHistoryShort": {
    "65b522a2a75c78c977a65e15663509509b5f12e0": "Ybodychange",
    "7231be592aa65ac1e91d0a319761f7e3df2225e9": "Ybodychange",
    "764741c5ce73f42f6451027c8f87d4021deac0e1": "Ybodychange",
    "14158070bf8b3f831702061ffd657c84179fc639": "Ybodychange",
    "b9996908b1fac66526395414cc5c3a14a1567d4e": "Ymultichange(Yrename,Ymodifierchange)",
    "337f5bbb8e12580e03274c15e90ccf702da6cc90": "Ybodychange",
    "64ae8b6a37249d099b5043ca39dc37c626e993ee": "Ybodychange",
    "a8f5efdb262bb9d55dcb71752f7cb41138ce6d7c": "Ybodychange",
    "5f9090a7f037e566c511c02eb6ae73ca2f6774cb": "Ybodychange",
    "81e2db10faaf0389f4e1af8c7132210946203157": "Yintroduced"
  },
  "changeHistoryDetails": {
    "65b522a2a75c78c977a65e15663509509b5f12e0": {
      "type": "Ybodychange",
      "commitMessage": "Better buffer leak reporting\n\n- Remove the reference to ResourceLeak from the buffer implementations\n  and use wrappers instead:\n  - SimpleLeakAwareByteBuf and AdvancedLeakAwareByteBuf\n  - It is now allocator\u0027s responsibility to create a leak-aware buffer.\n  - Added AbstractByteBufAllocator.toLeakAwareBuffer() for easier\n    implementation\n- Add WrappedByteBuf to reduce duplication between *LeakAwareByteBuf and\n  UnreleasableByteBuf\n- Raise the level of leak reports to ERROR - because it will break the\n  app eventually\n- Replace enabled/disabled property with the leak detection level\n  - Only print stack trace when level is ADVANCED or above to avoid user\n    confusion\n- Add the \u0027leak\u0027 build profile, which enables highly detailed leak\n  reporting during the build\n- Remove ResourceLeakException which is unsed anymore\n",
      "commitDate": "04/12/13 7:51 AM",
      "commitName": "65b522a2a75c78c977a65e15663509509b5f12e0",
      "commitAuthor": "Trustin Lee",
      "commitDateOld": "12/11/13 3:40 AM",
      "commitNameOld": "7231be592aa65ac1e91d0a319761f7e3df2225e9",
      "commitAuthorOld": "Norman Maurer",
      "daysBetweenCommits": 22.17,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,16 +1,12 @@\n     protected void deallocate() {\n         ByteBuffer buffer \u003d this.buffer;\n         if (buffer \u003d\u003d null) {\n             return;\n         }\n \n         this.buffer \u003d null;\n \n         if (!doNotFree) {\n             freeDirect(buffer);\n         }\n-\n-        if (leak !\u003d null) {\n-            leak.close();\n-        }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void deallocate() {\n        ByteBuffer buffer \u003d this.buffer;\n        if (buffer \u003d\u003d null) {\n            return;\n        }\n\n        this.buffer \u003d null;\n\n        if (!doNotFree) {\n            freeDirect(buffer);\n        }\n    }",
      "path": "buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java",
      "extendedDetails": {}
    },
    "7231be592aa65ac1e91d0a319761f7e3df2225e9": {
      "type": "Ybodychange",
      "commitMessage": "Also allow to override how direct ByteBuffers are freed\n",
      "commitDate": "12/11/13 3:40 AM",
      "commitName": "7231be592aa65ac1e91d0a319761f7e3df2225e9",
      "commitAuthor": "Norman Maurer",
      "commitDateOld": "12/11/13 3:13 AM",
      "commitNameOld": "e83fb821d512456113a5e16b21ddb5c5458d9e79",
      "commitAuthorOld": "Norman Maurer",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,16 +1,16 @@\n     protected void deallocate() {\n         ByteBuffer buffer \u003d this.buffer;\n         if (buffer \u003d\u003d null) {\n             return;\n         }\n \n         this.buffer \u003d null;\n \n         if (!doNotFree) {\n-            PlatformDependent.freeDirectBuffer(buffer);\n+            freeDirect(buffer);\n         }\n \n         if (leak !\u003d null) {\n             leak.close();\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void deallocate() {\n        ByteBuffer buffer \u003d this.buffer;\n        if (buffer \u003d\u003d null) {\n            return;\n        }\n\n        this.buffer \u003d null;\n\n        if (!doNotFree) {\n            freeDirect(buffer);\n        }\n\n        if (leak !\u003d null) {\n            leak.close();\n        }\n    }",
      "path": "buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java",
      "extendedDetails": {}
    },
    "764741c5ce73f42f6451027c8f87d4021deac0e1": {
      "type": "Ybodychange",
      "commitMessage": "Change the contract of ResourceLeakDetector.open() so that unsampled resources are recycled\n\n- This also fixes the problem introduced while trying to implement #1612 (Allow to disable resource leak detection).\n",
      "commitDate": "22/07/13 10:06 PM",
      "commitName": "764741c5ce73f42f6451027c8f87d4021deac0e1",
      "commitAuthor": "Trustin Lee",
      "commitDateOld": "12/06/13 8:40 PM",
      "commitNameOld": "283feda119cf40746da5db0d63cda0a101eaec2e",
      "commitAuthorOld": "Trustin Lee",
      "daysBetweenCommits": 40.06,
      "commitsBetweenForRepo": 308,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,13 +1,16 @@\n     protected void deallocate() {\n         ByteBuffer buffer \u003d this.buffer;\n         if (buffer \u003d\u003d null) {\n             return;\n         }\n \n         this.buffer \u003d null;\n \n         if (!doNotFree) {\n             PlatformDependent.freeDirectBuffer(buffer);\n         }\n-        leak.close();\n+\n+        if (leak !\u003d null) {\n+            leak.close();\n+        }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void deallocate() {\n        ByteBuffer buffer \u003d this.buffer;\n        if (buffer \u003d\u003d null) {\n            return;\n        }\n\n        this.buffer \u003d null;\n\n        if (!doNotFree) {\n            PlatformDependent.freeDirectBuffer(buffer);\n        }\n\n        if (leak !\u003d null) {\n            leak.close();\n        }\n    }",
      "path": "buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java",
      "extendedDetails": {}
    },
    "14158070bf8b3f831702061ffd657c84179fc639": {
      "type": "Ybodychange",
      "commitMessage": "Revamp the core API to reduce memory footprint and consumption\n\nThe API changes made so far turned out to increase the memory footprint\nand consumption while our intention was actually decreasing them.\n\nMemory consumption issue:\n\nWhen there are many connections which does not exchange data frequently,\nthe old Netty 4 API spent a lot more memory than 3 because it always\nallocates per-handler buffer for each connection unless otherwise\nexplicitly stated by a user.  In a usual real world load, a client\ndoesn\u0027t always send requests without pausing, so the idea of having a\nbuffer whose life cycle if bound to the life cycle of a connection\ndidn\u0027t work as expected.\n\nMemory footprint issue:\n\nThe old Netty 4 API decreased overall memory footprint by a great deal\nin many cases.  It was mainly because the old Netty 4 API did not\nallocate a new buffer and event object for each read.  Instead, it\ncreated a new buffer for each handler in a pipeline.  This works pretty\nwell as long as the number of handlers in a pipeline is only a few.\nHowever, for a highly modular application with many handlers which\nhandles connections which lasts for relatively short period, it actually\nmakes the memory footprint issue much worse.\n\nChanges:\n\nAll in all, this is about retaining all the good changes we made in 4 so\nfar such as better thread model and going back to the way how we dealt\nwith message events in 3.\n\nTo fix the memory consumption/footprint issue mentioned above, we made a\nhard decision to break the backward compatibility again with the\nfollowing changes:\n\n- Remove MessageBuf\n- Merge Buf into ByteBuf\n- Merge ChannelInboundByte/MessageHandler and ChannelStateHandler into ChannelInboundHandler\n  - Similar changes were made to the adapter classes\n- Merge ChannelOutboundByte/MessageHandler and ChannelOperationHandler into ChannelOutboundHandler\n  - Similar changes were made to the adapter classes\n- Introduce MessageList which is similar to `MessageEvent` in Netty 3\n- Replace inboundBufferUpdated(ctx) with messageReceived(ctx, MessageList)\n- Replace flush(ctx, promise) with write(ctx, MessageList, promise)\n- Remove ByteToByteEncoder/Decoder/Codec\n  - Replaced by MessageToByteEncoder\u003cByteBuf\u003e, ByteToMessageDecoder\u003cByteBuf\u003e, and ByteMessageCodec\u003cByteBuf\u003e\n- Merge EmbeddedByteChannel and EmbeddedMessageChannel into EmbeddedChannel\n- Add SimpleChannelInboundHandler which is sometimes more useful than\n  ChannelInboundHandlerAdapter\n- Bring back Channel.isWritable() from Netty 3\n- Add ChannelInboundHandler.channelWritabilityChanges() event\n- Add RecvByteBufAllocator configuration property\n  - Similar to ReceiveBufferSizePredictor in Netty 3\n  - Some existing configuration properties such as\n    DatagramChannelConfig.receivePacketSize is gone now.\n- Remove suspend/resumeIntermediaryDeallocation() in ByteBuf\n\nThis change would have been impossible without @normanmaurer\u0027s help. He\nfixed, ported, and improved many parts of the changes.\n",
      "commitDate": "10/06/13 12:10 AM",
      "commitName": "14158070bf8b3f831702061ffd657c84179fc639",
      "commitAuthor": "Trustin Lee",
      "commitDateOld": "22/04/13 1:07 AM",
      "commitNameOld": "9a5f45a0c1fdeea3b277addccbb73657f38293c5",
      "commitAuthorOld": "Norman Maurer",
      "daysBetweenCommits": 48.96,
      "commitsBetweenForRepo": 126,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,14 +1,13 @@\n     protected void deallocate() {\n         ByteBuffer buffer \u003d this.buffer;\n         if (buffer \u003d\u003d null) {\n             return;\n         }\n \n         this.buffer \u003d null;\n \n-        resumeIntermediaryDeallocations();\n         if (!doNotFree) {\n             PlatformDependent.freeDirectBuffer(buffer);\n         }\n         leak.close();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void deallocate() {\n        ByteBuffer buffer \u003d this.buffer;\n        if (buffer \u003d\u003d null) {\n            return;\n        }\n\n        this.buffer \u003d null;\n\n        if (!doNotFree) {\n            PlatformDependent.freeDirectBuffer(buffer);\n        }\n        leak.close();\n    }",
      "path": "buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java",
      "extendedDetails": {}
    },
    "b9996908b1fac66526395414cc5c3a14a1567d4e": {
      "type": "Ymultichange(Yrename,Ymodifierchange)",
      "commitMessage": "Implement reference counting\n\n- Related: #1029\n- Replace Freeable with ReferenceCounted\n- Add AbstractReferenceCounted\n- Add AbstractReferenceCountedByteBuf\n- Add AbstractDerivedByteBuf\n- Add EmptyByteBuf\n",
      "commitDate": "09/02/13 8:10 PM",
      "commitName": "b9996908b1fac66526395414cc5c3a14a1567d4e",
      "commitAuthor": "Trustin Lee",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "Implement reference counting\n\n- Related: #1029\n- Replace Freeable with ReferenceCounted\n- Add AbstractReferenceCounted\n- Add AbstractReferenceCountedByteBuf\n- Add AbstractDerivedByteBuf\n- Add EmptyByteBuf\n",
          "commitDate": "09/02/13 8:10 PM",
          "commitName": "b9996908b1fac66526395414cc5c3a14a1567d4e",
          "commitAuthor": "Trustin Lee",
          "commitDateOld": "17/01/13 8:10 PM",
          "commitNameOld": "d0afe6cad0eafb0f79d4b38c2e172be9bbb1f0c5",
          "commitAuthorOld": "Trustin Lee",
          "daysBetweenCommits": 23.0,
          "commitsBetweenForRepo": 143,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,14 +1,14 @@\n-    public void free() {\n+    protected void deallocate() {\n         ByteBuffer buffer \u003d this.buffer;\n         if (buffer \u003d\u003d null) {\n             return;\n         }\n \n         this.buffer \u003d null;\n \n         resumeIntermediaryDeallocations();\n         if (!doNotFree) {\n             PlatformDependent.freeDirectBuffer(buffer);\n         }\n         leak.close();\n     }\n\\ No newline at end of file\n",
          "actualSource": "    protected void deallocate() {\n        ByteBuffer buffer \u003d this.buffer;\n        if (buffer \u003d\u003d null) {\n            return;\n        }\n\n        this.buffer \u003d null;\n\n        resumeIntermediaryDeallocations();\n        if (!doNotFree) {\n            PlatformDependent.freeDirectBuffer(buffer);\n        }\n        leak.close();\n    }",
          "path": "buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java",
          "extendedDetails": {
            "oldValue": "free",
            "newValue": "deallocate"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "Implement reference counting\n\n- Related: #1029\n- Replace Freeable with ReferenceCounted\n- Add AbstractReferenceCounted\n- Add AbstractReferenceCountedByteBuf\n- Add AbstractDerivedByteBuf\n- Add EmptyByteBuf\n",
          "commitDate": "09/02/13 8:10 PM",
          "commitName": "b9996908b1fac66526395414cc5c3a14a1567d4e",
          "commitAuthor": "Trustin Lee",
          "commitDateOld": "17/01/13 8:10 PM",
          "commitNameOld": "d0afe6cad0eafb0f79d4b38c2e172be9bbb1f0c5",
          "commitAuthorOld": "Trustin Lee",
          "daysBetweenCommits": 23.0,
          "commitsBetweenForRepo": 143,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,14 +1,14 @@\n-    public void free() {\n+    protected void deallocate() {\n         ByteBuffer buffer \u003d this.buffer;\n         if (buffer \u003d\u003d null) {\n             return;\n         }\n \n         this.buffer \u003d null;\n \n         resumeIntermediaryDeallocations();\n         if (!doNotFree) {\n             PlatformDependent.freeDirectBuffer(buffer);\n         }\n         leak.close();\n     }\n\\ No newline at end of file\n",
          "actualSource": "    protected void deallocate() {\n        ByteBuffer buffer \u003d this.buffer;\n        if (buffer \u003d\u003d null) {\n            return;\n        }\n\n        this.buffer \u003d null;\n\n        resumeIntermediaryDeallocations();\n        if (!doNotFree) {\n            PlatformDependent.freeDirectBuffer(buffer);\n        }\n        leak.close();\n    }",
          "path": "buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[protected]"
          }
        }
      ]
    },
    "337f5bbb8e12580e03274c15e90ccf702da6cc90": {
      "type": "Ybodychange",
      "commitMessage": "Automatic diagnosis of resource leaks\n\nNow that we are going to use buffer pooling by default, it is obvious\nthat a user will forget to call .free() and report memory leak. In this\ncase, we should have a tool to determine if it is a bug in our allocator\nimplementation or in the user\u0027s code.\n\nThis pull request adds a system property flag called\n\u0027io.netty.resourceLeakDetection\u0027. If set, when a user forgets to call\n.free(), the ResourceLeakDetector will detect it and log a message with\ndetailed stack trace to tell where the leaked buffer has been allocated.\n\nBecause obtaining stack trace is an expensive operation, I used sampling\ntechnique. Allocation is recorded only for every 113th allocation. I\nchose 113 because it\u0027s a prime number.\n\nIn production, a user might not want to enable this option due to\npotential performance impact. If a user does not specify the\n\u0027-Dio.netty.resourceLeakDetection\u0027 option leak detection is disabled.\n\nEven if the leak detection is enabled, the overhead should be less than\n5% because only ~1% of allocations are monitored.\n\nI also replaced SharedResourceMisuseDetector with ResourceLeakDetector.\n",
      "commitDate": "14/01/13 9:15 PM",
      "commitName": "337f5bbb8e12580e03274c15e90ccf702da6cc90",
      "commitAuthor": "Trustin Lee",
      "commitDateOld": "10/01/13 9:03 PM",
      "commitNameOld": "64ae8b6a37249d099b5043ca39dc37c626e993ee",
      "commitAuthorOld": "Trustin Lee",
      "daysBetweenCommits": 4.01,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,15 +1,14 @@\n     public void free() {\n         ByteBuffer buffer \u003d this.buffer;\n         if (buffer \u003d\u003d null) {\n             return;\n         }\n \n         this.buffer \u003d null;\n \n-        if (doNotFree) {\n-            return;\n-        }\n-\n         resumeIntermediaryDeallocations();\n-        PlatformDependent.freeDirectBuffer(buffer);\n+        if (!doNotFree) {\n+            PlatformDependent.freeDirectBuffer(buffer);\n+        }\n+        leak.close();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void free() {\n        ByteBuffer buffer \u003d this.buffer;\n        if (buffer \u003d\u003d null) {\n            return;\n        }\n\n        this.buffer \u003d null;\n\n        resumeIntermediaryDeallocations();\n        if (!doNotFree) {\n            PlatformDependent.freeDirectBuffer(buffer);\n        }\n        leak.close();\n    }",
      "path": "buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java",
      "extendedDetails": {}
    },
    "64ae8b6a37249d099b5043ca39dc37c626e993ee": {
      "type": "Ybodychange",
      "commitMessage": "Replace and merge DetectionUtil and DirectByteBufUtil into PlatformDependent and PlatformDependent0\n\nPlatformDependent delegates the operations requires sun.misc.* to PlatformDependent0 to avoid runtime errors due to missing sun.misc.* classes.\n",
      "commitDate": "10/01/13 9:03 PM",
      "commitName": "64ae8b6a37249d099b5043ca39dc37c626e993ee",
      "commitAuthor": "Trustin Lee",
      "commitDateOld": "10/01/13 11:03 AM",
      "commitNameOld": "5b5b39a60611be3d9268c7891e8c26eba7100af0",
      "commitAuthorOld": "Norman Maurer",
      "daysBetweenCommits": 0.42,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,15 +1,15 @@\n     public void free() {\n         ByteBuffer buffer \u003d this.buffer;\n         if (buffer \u003d\u003d null) {\n             return;\n         }\n \n         this.buffer \u003d null;\n \n         if (doNotFree) {\n             return;\n         }\n \n         resumeIntermediaryDeallocations();\n-        freeDirect(buffer);\n+        PlatformDependent.freeDirectBuffer(buffer);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void free() {\n        ByteBuffer buffer \u003d this.buffer;\n        if (buffer \u003d\u003d null) {\n            return;\n        }\n\n        this.buffer \u003d null;\n\n        if (doNotFree) {\n            return;\n        }\n\n        resumeIntermediaryDeallocations();\n        PlatformDependent.freeDirectBuffer(buffer);\n    }",
      "path": "buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java",
      "extendedDetails": {}
    },
    "a8f5efdb262bb9d55dcb71752f7cb41138ce6d7c": {
      "type": "Ybodychange",
      "commitMessage": "Add proper boundary / freeness check on ByteBuf impls\n\n- Fixes #827\n",
      "commitDate": "17/12/12 1:27 AM",
      "commitName": "a8f5efdb262bb9d55dcb71752f7cb41138ce6d7c",
      "commitAuthor": "Trustin Lee",
      "commitDateOld": "17/12/12 12:41 AM",
      "commitNameOld": "03e68482bba54aa0c0d35649ac9c090b0ab75473",
      "commitAuthorOld": "Trustin Lee",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,13 +1,15 @@\n     public void free() {\n-        if (freed) {\n+        ByteBuffer buffer \u003d this.buffer;\n+        if (buffer \u003d\u003d null) {\n             return;\n         }\n \n-        freed \u003d true;\n+        this.buffer \u003d null;\n+\n         if (doNotFree) {\n             return;\n         }\n \n         resumeIntermediaryDeallocations();\n         freeDirect(buffer);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void free() {\n        ByteBuffer buffer \u003d this.buffer;\n        if (buffer \u003d\u003d null) {\n            return;\n        }\n\n        this.buffer \u003d null;\n\n        if (doNotFree) {\n            return;\n        }\n\n        resumeIntermediaryDeallocations();\n        freeDirect(buffer);\n    }",
      "path": "buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java",
      "extendedDetails": {}
    },
    "5f9090a7f037e566c511c02eb6ae73ca2f6774cb": {
      "type": "Ybodychange",
      "commitMessage": "Fix invalid memory access in AIO writes\n\nTo perform writes in AioSocketChannel, we get a ByteBuffer view of the\noutbound buffer and specify it as a parameter when we call\nAsynchronousSocketChannel.write().\n\nIn most cases, the write() operation is finished immediately.  However,\nsometimes, it is scheduled for later execution.  In such a case, there\u0027s\na chance for a user\u0027s handler to append more data to the outbound\nbuffer.\n\nWhen more data is appended to the outbound buffer, the outbound buffer\ncan expand its capacity by itself.  Changing the capacity of a buffer is\nbasically made of the following steps:\n\n1. Allocate a larger new internal memory region.\n2. Copy the current content of the buffer to the new memory region.\n3. Rewire the buffer so that it refers to the new region.\n4. Deallocate the old memory region.\n\nBecause the old memory region is deallocated at the step 4, the write\noperation scheduled later will access the deallocated region, leading\nall sort of data corruption or even segfaults.\n\nTo prevent this situation, I added suspendIntermediaryDeallocations()\nand resumeIntermediaryDeallocations() to UnsafeByteBuf.\n\nAioSocketChannel.doFlushByteBuf() now calls suspendIntermediaryDealloc()\nto defer the deallocation of the old memory regions until the completion\nhandler is notified.\n",
      "commitDate": "02/12/12 4:50 AM",
      "commitName": "5f9090a7f037e566c511c02eb6ae73ca2f6774cb",
      "commitAuthor": "Trustin Lee",
      "commitDateOld": "02/12/12 3:17 AM",
      "commitNameOld": "bfe2a96505b52fcc990d7e8e990c3a8676c42c5d",
      "commitAuthorOld": "Trustin Lee",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,12 +1,13 @@\n     public void free() {\n         if (freed) {\n             return;\n         }\n \n         freed \u003d true;\n         if (doNotFree) {\n             return;\n         }\n \n+        resumeIntermediaryDeallocations();\n         freeDirect(buffer);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void free() {\n        if (freed) {\n            return;\n        }\n\n        freed \u003d true;\n        if (doNotFree) {\n            return;\n        }\n\n        resumeIntermediaryDeallocations();\n        freeDirect(buffer);\n    }",
      "path": "buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java",
      "extendedDetails": {}
    },
    "81e2db10faaf0389f4e1af8c7132210946203157": {
      "type": "Yintroduced",
      "commitMessage": "ByteBufAllocator API w/ ByteBuf perf improvements\n\nThis commit introduces a new API for ByteBuf allocation which fixes\nissue #643 along with refactoring of ByteBuf for simplicity and better\nperformance. (see #62)\n\nA user can configure the ByteBufAllocator of a Channel via\nChannelOption.ALLOCATOR or ChannelConfig.get/setAllocator().  The\ndefault allocator is currently UnpooledByteBufAllocator.HEAP_BY_DEFAULT.\n\nTo allocate a buffer, do not use Unpooled anymore. do the following:\n\n  ctx.alloc().buffer(...); // allocator chooses the buffer type.\n  ctx.alloc().heapBuffer(...);\n  ctx.alloc().directBuffer(...);\n\nTo deallocate a buffer, use the unsafe free() operation:\n\n  ((UnsafeByteBuf) buf).free();\n\nThe following is the list of the relevant changes:\n\n- Add ChannelInboundHandler.freeInboundBuffer() and\n  ChannelOutboundHandler.freeOutboundBuffer() to let a user free the\n  buffer he or she allocated. ChannelHandler adapter classes implement\n  is already, so most users won\u0027t need to call free() by themselves.\n  freeIn/OutboundBuffer() methods are invoked when a Channel is closed\n  and deregistered.\n\n- All ByteBuf by contract must implement UnsafeByteBuf. To access an\n  unsafe operation: ((UnsafeByteBuf) buf).internalNioBuffer()\n\n- Replace WrappedByteBuf and ByteBuf.Unsafe with UnsafeByteBuf to\n  simplify overall class hierarchy and to avoid unnecesary instantiation\n  of Unsafe instances on an unsafe operation.\n\n- Remove buffer reference counting which is confusing\n\n- Instantiate SwappedByteBuf lazily to avoid instantiation cost\n\n- Rename ChannelFutureFactory to ChannelPropertyAccess and move common\n  methods between Channel and ChannelHandlerContext there. Also made it\n  package-private to hide it from a user.\n\n- Remove unused unsafe operations such as newBuffer()\n\n- Add DetectionUtil.canFreeDirectBuffer() so that an allocator decides\n  which buffer type to use safely\n",
      "commitDate": "21/11/12 10:10 PM",
      "commitName": "81e2db10faaf0389f4e1af8c7132210946203157",
      "commitAuthor": "Trustin Lee",
      "diff": "@@ -0,0 +1,12 @@\n+    public void free() {\n+        if (freed) {\n+            return;\n+        }\n+\n+        freed \u003d true;\n+        if (doNotFree) {\n+            return;\n+        }\n+\n+        freeDirect(buffer);\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public void free() {\n        if (freed) {\n            return;\n        }\n\n        freed \u003d true;\n        if (doNotFree) {\n            return;\n        }\n\n        freeDirect(buffer);\n    }",
      "path": "buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java"
    }
  }
}