{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CBZip2OutputStream.java",
  "functionName": "mainSimpleSort",
  "functionId": "mainSimpleSort___dataShadow-Data(modifiers-final)__lo-int(modifiers-final)__hi-int(modifiers-final)__d-int(modifiers-final)",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/compress/bzip2/CBZip2OutputStream.java",
  "functionStartLine": 1405,
  "functionEndLine": 1587,
  "numCommitsSeen": 7,
  "timeTaken": 1036,
  "changeHistory": [
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36"
  ],
  "changeHistoryShort": {
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private boolean mainSimpleSort(final Data dataShadow, final int lo,\n      final int hi, final int d) {\n    final int bigN \u003d hi - lo + 1;\n    if (bigN \u003c 2) {\n      return this.firstAttempt \u0026\u0026 (this.workDone \u003e this.workLimit);\n    }\n\n    int hp \u003d 0;\n    while (INCS[hp] \u003c bigN) {\n      hp++;\n    }\n\n    final int[] fmap \u003d dataShadow.fmap;\n    final char[] quadrant \u003d dataShadow.quadrant;\n    final byte[] block \u003d dataShadow.block;\n    final int lastShadow \u003d this.last;\n    final int lastPlus1 \u003d lastShadow + 1;\n    final boolean firstAttemptShadow \u003d this.firstAttempt;\n    final int workLimitShadow \u003d this.workLimit;\n    int workDoneShadow \u003d this.workDone;\n\n    // Following block contains unrolled code which could be shortened by\n    // coding it in additional loops.\n\n    HP: while (--hp \u003e\u003d 0) {\n      final int h \u003d INCS[hp];\n      final int mj \u003d lo + h - 1;\n\n      for (int i \u003d lo + h; i \u003c\u003d hi;) {\n        // copy\n        for (int k \u003d 3; (i \u003c\u003d hi) \u0026\u0026 (--k \u003e\u003d 0); i++) {\n          final int v \u003d fmap[i];\n          final int vd \u003d v + d;\n          int j \u003d i;\n\n          // for (int a;\n          // (j \u003e mj) \u0026\u0026 mainGtU((a \u003d fmap[j - h]) + d, vd,\n          // block, quadrant, lastShadow);\n          // j -\u003d h) {\n          // fmap[j] \u003d a;\n          // }\n          //\n          // unrolled version:\n\n          // start inline mainGTU\n          boolean onceRunned \u003d false;\n          int a \u003d 0;\n\n          HAMMER: while (true) {\n            if (onceRunned) {\n              fmap[j] \u003d a;\n              if ((j -\u003d h) \u003c\u003d mj) {\n                break HAMMER;\n              }\n            } else {\n              onceRunned \u003d true;\n            }\n\n            a \u003d fmap[j - h];\n            int i1 \u003d a + d;\n            int i2 \u003d vd;\n\n            // following could be done in a loop, but\n            // unrolled it for performance:\n            if (block[i1 + 1] \u003d\u003d block[i2 + 1]) {\n              if (block[i1 + 2] \u003d\u003d block[i2 + 2]) {\n                if (block[i1 + 3] \u003d\u003d block[i2 + 3]) {\n                  if (block[i1 + 4] \u003d\u003d block[i2 + 4]) {\n                    if (block[i1 + 5] \u003d\u003d block[i2 + 5]) {\n                      if (block[(i1 +\u003d 6)] \u003d\u003d block[(i2 +\u003d 6)]) {\n                        int x \u003d lastShadow;\n                        X: while (x \u003e 0) {\n                          x -\u003d 4;\n\n                          if (block[i1 + 1] \u003d\u003d block[i2 + 1]) {\n                            if (quadrant[i1] \u003d\u003d quadrant[i2]) {\n                              if (block[i1 + 2] \u003d\u003d block[i2 + 2]) {\n                                if (quadrant[i1 + 1] \u003d\u003d quadrant[i2 + 1]) {\n                                  if (block[i1 + 3] \u003d\u003d block[i2 + 3]) {\n                                    if (quadrant[i1 + 2] \u003d\u003d quadrant[i2 + 2]) {\n                                      if (block[i1 + 4] \u003d\u003d block[i2 + 4]) {\n                                        if (quadrant[i1 + 3] \u003d\u003d quadrant[i2 + 3]) {\n                                          if ((i1 +\u003d 4) \u003e\u003d lastPlus1) {\n                                            i1 -\u003d lastPlus1;\n                                          }\n                                          if ((i2 +\u003d 4) \u003e\u003d lastPlus1) {\n                                            i2 -\u003d lastPlus1;\n                                          }\n                                          workDoneShadow++;\n                                          continue X;\n                                        } else if ((quadrant[i1 + 3] \u003e quadrant[i2 + 3])) {\n                                          continue HAMMER;\n                                        } else {\n                                          break HAMMER;\n                                        }\n                                      } else if ((block[i1 + 4] \u0026 0xff) \u003e (block[i2 + 4] \u0026 0xff)) {\n                                        continue HAMMER;\n                                      } else {\n                                        break HAMMER;\n                                      }\n                                    } else if ((quadrant[i1 + 2] \u003e quadrant[i2 + 2])) {\n                                      continue HAMMER;\n                                    } else {\n                                      break HAMMER;\n                                    }\n                                  } else if ((block[i1 + 3] \u0026 0xff) \u003e (block[i2 + 3] \u0026 0xff)) {\n                                    continue HAMMER;\n                                  } else {\n                                    break HAMMER;\n                                  }\n                                } else if ((quadrant[i1 + 1] \u003e quadrant[i2 + 1])) {\n                                  continue HAMMER;\n                                } else {\n                                  break HAMMER;\n                                }\n                              } else if ((block[i1 + 2] \u0026 0xff) \u003e (block[i2 + 2] \u0026 0xff)) {\n                                continue HAMMER;\n                              } else {\n                                break HAMMER;\n                              }\n                            } else if ((quadrant[i1] \u003e quadrant[i2])) {\n                              continue HAMMER;\n                            } else {\n                              break HAMMER;\n                            }\n                          } else if ((block[i1 + 1] \u0026 0xff) \u003e (block[i2 + 1] \u0026 0xff)) {\n                            continue HAMMER;\n                          } else {\n                            break HAMMER;\n                          }\n\n                        }\n                        break HAMMER;\n                      } // while x \u003e 0\n                      else {\n                        if ((block[i1] \u0026 0xff) \u003e (block[i2] \u0026 0xff)) {\n                          continue HAMMER;\n                        } else {\n                          break HAMMER;\n                        }\n                      }\n                    } else if ((block[i1 + 5] \u0026 0xff) \u003e (block[i2 + 5] \u0026 0xff)) {\n                      continue HAMMER;\n                    } else {\n                      break HAMMER;\n                    }\n                  } else if ((block[i1 + 4] \u0026 0xff) \u003e (block[i2 + 4] \u0026 0xff)) {\n                    continue HAMMER;\n                  } else {\n                    break HAMMER;\n                  }\n                } else if ((block[i1 + 3] \u0026 0xff) \u003e (block[i2 + 3] \u0026 0xff)) {\n                  continue HAMMER;\n                } else {\n                  break HAMMER;\n                }\n              } else if ((block[i1 + 2] \u0026 0xff) \u003e (block[i2 + 2] \u0026 0xff)) {\n                continue HAMMER;\n              } else {\n                break HAMMER;\n              }\n            } else if ((block[i1 + 1] \u0026 0xff) \u003e (block[i2 + 1] \u0026 0xff)) {\n              continue HAMMER;\n            } else {\n              break HAMMER;\n            }\n\n          } // HAMMER\n          // end inline mainGTU\n\n          fmap[j] \u003d v;\n        }\n\n        if (firstAttemptShadow \u0026\u0026 (i \u003c\u003d hi)\n            \u0026\u0026 (workDoneShadow \u003e workLimitShadow)) {\n          break HP;\n        }\n      }\n    }\n\n    this.workDone \u003d workDoneShadow;\n    return firstAttemptShadow \u0026\u0026 (workDoneShadow \u003e workLimitShadow);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/compress/bzip2/CBZip2OutputStream.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/io/compress/bzip2/CBZip2OutputStream.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/compress/bzip2/CBZip2OutputStream.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private boolean mainSimpleSort(final Data dataShadow, final int lo,\n      final int hi, final int d) {\n    final int bigN \u003d hi - lo + 1;\n    if (bigN \u003c 2) {\n      return this.firstAttempt \u0026\u0026 (this.workDone \u003e this.workLimit);\n    }\n\n    int hp \u003d 0;\n    while (INCS[hp] \u003c bigN) {\n      hp++;\n    }\n\n    final int[] fmap \u003d dataShadow.fmap;\n    final char[] quadrant \u003d dataShadow.quadrant;\n    final byte[] block \u003d dataShadow.block;\n    final int lastShadow \u003d this.last;\n    final int lastPlus1 \u003d lastShadow + 1;\n    final boolean firstAttemptShadow \u003d this.firstAttempt;\n    final int workLimitShadow \u003d this.workLimit;\n    int workDoneShadow \u003d this.workDone;\n\n    // Following block contains unrolled code which could be shortened by\n    // coding it in additional loops.\n\n    HP: while (--hp \u003e\u003d 0) {\n      final int h \u003d INCS[hp];\n      final int mj \u003d lo + h - 1;\n\n      for (int i \u003d lo + h; i \u003c\u003d hi;) {\n        // copy\n        for (int k \u003d 3; (i \u003c\u003d hi) \u0026\u0026 (--k \u003e\u003d 0); i++) {\n          final int v \u003d fmap[i];\n          final int vd \u003d v + d;\n          int j \u003d i;\n\n          // for (int a;\n          // (j \u003e mj) \u0026\u0026 mainGtU((a \u003d fmap[j - h]) + d, vd,\n          // block, quadrant, lastShadow);\n          // j -\u003d h) {\n          // fmap[j] \u003d a;\n          // }\n          //\n          // unrolled version:\n\n          // start inline mainGTU\n          boolean onceRunned \u003d false;\n          int a \u003d 0;\n\n          HAMMER: while (true) {\n            if (onceRunned) {\n              fmap[j] \u003d a;\n              if ((j -\u003d h) \u003c\u003d mj) {\n                break HAMMER;\n              }\n            } else {\n              onceRunned \u003d true;\n            }\n\n            a \u003d fmap[j - h];\n            int i1 \u003d a + d;\n            int i2 \u003d vd;\n\n            // following could be done in a loop, but\n            // unrolled it for performance:\n            if (block[i1 + 1] \u003d\u003d block[i2 + 1]) {\n              if (block[i1 + 2] \u003d\u003d block[i2 + 2]) {\n                if (block[i1 + 3] \u003d\u003d block[i2 + 3]) {\n                  if (block[i1 + 4] \u003d\u003d block[i2 + 4]) {\n                    if (block[i1 + 5] \u003d\u003d block[i2 + 5]) {\n                      if (block[(i1 +\u003d 6)] \u003d\u003d block[(i2 +\u003d 6)]) {\n                        int x \u003d lastShadow;\n                        X: while (x \u003e 0) {\n                          x -\u003d 4;\n\n                          if (block[i1 + 1] \u003d\u003d block[i2 + 1]) {\n                            if (quadrant[i1] \u003d\u003d quadrant[i2]) {\n                              if (block[i1 + 2] \u003d\u003d block[i2 + 2]) {\n                                if (quadrant[i1 + 1] \u003d\u003d quadrant[i2 + 1]) {\n                                  if (block[i1 + 3] \u003d\u003d block[i2 + 3]) {\n                                    if (quadrant[i1 + 2] \u003d\u003d quadrant[i2 + 2]) {\n                                      if (block[i1 + 4] \u003d\u003d block[i2 + 4]) {\n                                        if (quadrant[i1 + 3] \u003d\u003d quadrant[i2 + 3]) {\n                                          if ((i1 +\u003d 4) \u003e\u003d lastPlus1) {\n                                            i1 -\u003d lastPlus1;\n                                          }\n                                          if ((i2 +\u003d 4) \u003e\u003d lastPlus1) {\n                                            i2 -\u003d lastPlus1;\n                                          }\n                                          workDoneShadow++;\n                                          continue X;\n                                        } else if ((quadrant[i1 + 3] \u003e quadrant[i2 + 3])) {\n                                          continue HAMMER;\n                                        } else {\n                                          break HAMMER;\n                                        }\n                                      } else if ((block[i1 + 4] \u0026 0xff) \u003e (block[i2 + 4] \u0026 0xff)) {\n                                        continue HAMMER;\n                                      } else {\n                                        break HAMMER;\n                                      }\n                                    } else if ((quadrant[i1 + 2] \u003e quadrant[i2 + 2])) {\n                                      continue HAMMER;\n                                    } else {\n                                      break HAMMER;\n                                    }\n                                  } else if ((block[i1 + 3] \u0026 0xff) \u003e (block[i2 + 3] \u0026 0xff)) {\n                                    continue HAMMER;\n                                  } else {\n                                    break HAMMER;\n                                  }\n                                } else if ((quadrant[i1 + 1] \u003e quadrant[i2 + 1])) {\n                                  continue HAMMER;\n                                } else {\n                                  break HAMMER;\n                                }\n                              } else if ((block[i1 + 2] \u0026 0xff) \u003e (block[i2 + 2] \u0026 0xff)) {\n                                continue HAMMER;\n                              } else {\n                                break HAMMER;\n                              }\n                            } else if ((quadrant[i1] \u003e quadrant[i2])) {\n                              continue HAMMER;\n                            } else {\n                              break HAMMER;\n                            }\n                          } else if ((block[i1 + 1] \u0026 0xff) \u003e (block[i2 + 1] \u0026 0xff)) {\n                            continue HAMMER;\n                          } else {\n                            break HAMMER;\n                          }\n\n                        }\n                        break HAMMER;\n                      } // while x \u003e 0\n                      else {\n                        if ((block[i1] \u0026 0xff) \u003e (block[i2] \u0026 0xff)) {\n                          continue HAMMER;\n                        } else {\n                          break HAMMER;\n                        }\n                      }\n                    } else if ((block[i1 + 5] \u0026 0xff) \u003e (block[i2 + 5] \u0026 0xff)) {\n                      continue HAMMER;\n                    } else {\n                      break HAMMER;\n                    }\n                  } else if ((block[i1 + 4] \u0026 0xff) \u003e (block[i2 + 4] \u0026 0xff)) {\n                    continue HAMMER;\n                  } else {\n                    break HAMMER;\n                  }\n                } else if ((block[i1 + 3] \u0026 0xff) \u003e (block[i2 + 3] \u0026 0xff)) {\n                  continue HAMMER;\n                } else {\n                  break HAMMER;\n                }\n              } else if ((block[i1 + 2] \u0026 0xff) \u003e (block[i2 + 2] \u0026 0xff)) {\n                continue HAMMER;\n              } else {\n                break HAMMER;\n              }\n            } else if ((block[i1 + 1] \u0026 0xff) \u003e (block[i2 + 1] \u0026 0xff)) {\n              continue HAMMER;\n            } else {\n              break HAMMER;\n            }\n\n          } // HAMMER\n          // end inline mainGTU\n\n          fmap[j] \u003d v;\n        }\n\n        if (firstAttemptShadow \u0026\u0026 (i \u003c\u003d hi)\n            \u0026\u0026 (workDoneShadow \u003e workLimitShadow)) {\n          break HP;\n        }\n      }\n    }\n\n    this.workDone \u003d workDoneShadow;\n    return firstAttemptShadow \u0026\u0026 (workDoneShadow \u003e workLimitShadow);\n  }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/io/compress/bzip2/CBZip2OutputStream.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/io/compress/bzip2/CBZip2OutputStream.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/io/compress/bzip2/CBZip2OutputStream.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private boolean mainSimpleSort(final Data dataShadow, final int lo,\n      final int hi, final int d) {\n    final int bigN \u003d hi - lo + 1;\n    if (bigN \u003c 2) {\n      return this.firstAttempt \u0026\u0026 (this.workDone \u003e this.workLimit);\n    }\n\n    int hp \u003d 0;\n    while (INCS[hp] \u003c bigN) {\n      hp++;\n    }\n\n    final int[] fmap \u003d dataShadow.fmap;\n    final char[] quadrant \u003d dataShadow.quadrant;\n    final byte[] block \u003d dataShadow.block;\n    final int lastShadow \u003d this.last;\n    final int lastPlus1 \u003d lastShadow + 1;\n    final boolean firstAttemptShadow \u003d this.firstAttempt;\n    final int workLimitShadow \u003d this.workLimit;\n    int workDoneShadow \u003d this.workDone;\n\n    // Following block contains unrolled code which could be shortened by\n    // coding it in additional loops.\n\n    HP: while (--hp \u003e\u003d 0) {\n      final int h \u003d INCS[hp];\n      final int mj \u003d lo + h - 1;\n\n      for (int i \u003d lo + h; i \u003c\u003d hi;) {\n        // copy\n        for (int k \u003d 3; (i \u003c\u003d hi) \u0026\u0026 (--k \u003e\u003d 0); i++) {\n          final int v \u003d fmap[i];\n          final int vd \u003d v + d;\n          int j \u003d i;\n\n          // for (int a;\n          // (j \u003e mj) \u0026\u0026 mainGtU((a \u003d fmap[j - h]) + d, vd,\n          // block, quadrant, lastShadow);\n          // j -\u003d h) {\n          // fmap[j] \u003d a;\n          // }\n          //\n          // unrolled version:\n\n          // start inline mainGTU\n          boolean onceRunned \u003d false;\n          int a \u003d 0;\n\n          HAMMER: while (true) {\n            if (onceRunned) {\n              fmap[j] \u003d a;\n              if ((j -\u003d h) \u003c\u003d mj) {\n                break HAMMER;\n              }\n            } else {\n              onceRunned \u003d true;\n            }\n\n            a \u003d fmap[j - h];\n            int i1 \u003d a + d;\n            int i2 \u003d vd;\n\n            // following could be done in a loop, but\n            // unrolled it for performance:\n            if (block[i1 + 1] \u003d\u003d block[i2 + 1]) {\n              if (block[i1 + 2] \u003d\u003d block[i2 + 2]) {\n                if (block[i1 + 3] \u003d\u003d block[i2 + 3]) {\n                  if (block[i1 + 4] \u003d\u003d block[i2 + 4]) {\n                    if (block[i1 + 5] \u003d\u003d block[i2 + 5]) {\n                      if (block[(i1 +\u003d 6)] \u003d\u003d block[(i2 +\u003d 6)]) {\n                        int x \u003d lastShadow;\n                        X: while (x \u003e 0) {\n                          x -\u003d 4;\n\n                          if (block[i1 + 1] \u003d\u003d block[i2 + 1]) {\n                            if (quadrant[i1] \u003d\u003d quadrant[i2]) {\n                              if (block[i1 + 2] \u003d\u003d block[i2 + 2]) {\n                                if (quadrant[i1 + 1] \u003d\u003d quadrant[i2 + 1]) {\n                                  if (block[i1 + 3] \u003d\u003d block[i2 + 3]) {\n                                    if (quadrant[i1 + 2] \u003d\u003d quadrant[i2 + 2]) {\n                                      if (block[i1 + 4] \u003d\u003d block[i2 + 4]) {\n                                        if (quadrant[i1 + 3] \u003d\u003d quadrant[i2 + 3]) {\n                                          if ((i1 +\u003d 4) \u003e\u003d lastPlus1) {\n                                            i1 -\u003d lastPlus1;\n                                          }\n                                          if ((i2 +\u003d 4) \u003e\u003d lastPlus1) {\n                                            i2 -\u003d lastPlus1;\n                                          }\n                                          workDoneShadow++;\n                                          continue X;\n                                        } else if ((quadrant[i1 + 3] \u003e quadrant[i2 + 3])) {\n                                          continue HAMMER;\n                                        } else {\n                                          break HAMMER;\n                                        }\n                                      } else if ((block[i1 + 4] \u0026 0xff) \u003e (block[i2 + 4] \u0026 0xff)) {\n                                        continue HAMMER;\n                                      } else {\n                                        break HAMMER;\n                                      }\n                                    } else if ((quadrant[i1 + 2] \u003e quadrant[i2 + 2])) {\n                                      continue HAMMER;\n                                    } else {\n                                      break HAMMER;\n                                    }\n                                  } else if ((block[i1 + 3] \u0026 0xff) \u003e (block[i2 + 3] \u0026 0xff)) {\n                                    continue HAMMER;\n                                  } else {\n                                    break HAMMER;\n                                  }\n                                } else if ((quadrant[i1 + 1] \u003e quadrant[i2 + 1])) {\n                                  continue HAMMER;\n                                } else {\n                                  break HAMMER;\n                                }\n                              } else if ((block[i1 + 2] \u0026 0xff) \u003e (block[i2 + 2] \u0026 0xff)) {\n                                continue HAMMER;\n                              } else {\n                                break HAMMER;\n                              }\n                            } else if ((quadrant[i1] \u003e quadrant[i2])) {\n                              continue HAMMER;\n                            } else {\n                              break HAMMER;\n                            }\n                          } else if ((block[i1 + 1] \u0026 0xff) \u003e (block[i2 + 1] \u0026 0xff)) {\n                            continue HAMMER;\n                          } else {\n                            break HAMMER;\n                          }\n\n                        }\n                        break HAMMER;\n                      } // while x \u003e 0\n                      else {\n                        if ((block[i1] \u0026 0xff) \u003e (block[i2] \u0026 0xff)) {\n                          continue HAMMER;\n                        } else {\n                          break HAMMER;\n                        }\n                      }\n                    } else if ((block[i1 + 5] \u0026 0xff) \u003e (block[i2 + 5] \u0026 0xff)) {\n                      continue HAMMER;\n                    } else {\n                      break HAMMER;\n                    }\n                  } else if ((block[i1 + 4] \u0026 0xff) \u003e (block[i2 + 4] \u0026 0xff)) {\n                    continue HAMMER;\n                  } else {\n                    break HAMMER;\n                  }\n                } else if ((block[i1 + 3] \u0026 0xff) \u003e (block[i2 + 3] \u0026 0xff)) {\n                  continue HAMMER;\n                } else {\n                  break HAMMER;\n                }\n              } else if ((block[i1 + 2] \u0026 0xff) \u003e (block[i2 + 2] \u0026 0xff)) {\n                continue HAMMER;\n              } else {\n                break HAMMER;\n              }\n            } else if ((block[i1 + 1] \u0026 0xff) \u003e (block[i2 + 1] \u0026 0xff)) {\n              continue HAMMER;\n            } else {\n              break HAMMER;\n            }\n\n          } // HAMMER\n          // end inline mainGTU\n\n          fmap[j] \u003d v;\n        }\n\n        if (firstAttemptShadow \u0026\u0026 (i \u003c\u003d hi)\n            \u0026\u0026 (workDoneShadow \u003e workLimitShadow)) {\n          break HP;\n        }\n      }\n    }\n\n    this.workDone \u003d workDoneShadow;\n    return firstAttemptShadow \u0026\u0026 (workDoneShadow \u003e workLimitShadow);\n  }",
      "path": "common/src/java/org/apache/hadoop/io/compress/bzip2/CBZip2OutputStream.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/io/compress/bzip2/CBZip2OutputStream.java",
        "newPath": "common/src/java/org/apache/hadoop/io/compress/bzip2/CBZip2OutputStream.java"
      }
    },
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-4687 Moving src directories on branch\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/core/branches/HADOOP-4687/core@776174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/05/09 9:20 PM",
      "commitName": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
      "commitAuthor": "Owen O\u0027Malley",
      "diff": "@@ -0,0 +1,183 @@\n+  private boolean mainSimpleSort(final Data dataShadow, final int lo,\n+      final int hi, final int d) {\n+    final int bigN \u003d hi - lo + 1;\n+    if (bigN \u003c 2) {\n+      return this.firstAttempt \u0026\u0026 (this.workDone \u003e this.workLimit);\n+    }\n+\n+    int hp \u003d 0;\n+    while (INCS[hp] \u003c bigN) {\n+      hp++;\n+    }\n+\n+    final int[] fmap \u003d dataShadow.fmap;\n+    final char[] quadrant \u003d dataShadow.quadrant;\n+    final byte[] block \u003d dataShadow.block;\n+    final int lastShadow \u003d this.last;\n+    final int lastPlus1 \u003d lastShadow + 1;\n+    final boolean firstAttemptShadow \u003d this.firstAttempt;\n+    final int workLimitShadow \u003d this.workLimit;\n+    int workDoneShadow \u003d this.workDone;\n+\n+    // Following block contains unrolled code which could be shortened by\n+    // coding it in additional loops.\n+\n+    HP: while (--hp \u003e\u003d 0) {\n+      final int h \u003d INCS[hp];\n+      final int mj \u003d lo + h - 1;\n+\n+      for (int i \u003d lo + h; i \u003c\u003d hi;) {\n+        // copy\n+        for (int k \u003d 3; (i \u003c\u003d hi) \u0026\u0026 (--k \u003e\u003d 0); i++) {\n+          final int v \u003d fmap[i];\n+          final int vd \u003d v + d;\n+          int j \u003d i;\n+\n+          // for (int a;\n+          // (j \u003e mj) \u0026\u0026 mainGtU((a \u003d fmap[j - h]) + d, vd,\n+          // block, quadrant, lastShadow);\n+          // j -\u003d h) {\n+          // fmap[j] \u003d a;\n+          // }\n+          //\n+          // unrolled version:\n+\n+          // start inline mainGTU\n+          boolean onceRunned \u003d false;\n+          int a \u003d 0;\n+\n+          HAMMER: while (true) {\n+            if (onceRunned) {\n+              fmap[j] \u003d a;\n+              if ((j -\u003d h) \u003c\u003d mj) {\n+                break HAMMER;\n+              }\n+            } else {\n+              onceRunned \u003d true;\n+            }\n+\n+            a \u003d fmap[j - h];\n+            int i1 \u003d a + d;\n+            int i2 \u003d vd;\n+\n+            // following could be done in a loop, but\n+            // unrolled it for performance:\n+            if (block[i1 + 1] \u003d\u003d block[i2 + 1]) {\n+              if (block[i1 + 2] \u003d\u003d block[i2 + 2]) {\n+                if (block[i1 + 3] \u003d\u003d block[i2 + 3]) {\n+                  if (block[i1 + 4] \u003d\u003d block[i2 + 4]) {\n+                    if (block[i1 + 5] \u003d\u003d block[i2 + 5]) {\n+                      if (block[(i1 +\u003d 6)] \u003d\u003d block[(i2 +\u003d 6)]) {\n+                        int x \u003d lastShadow;\n+                        X: while (x \u003e 0) {\n+                          x -\u003d 4;\n+\n+                          if (block[i1 + 1] \u003d\u003d block[i2 + 1]) {\n+                            if (quadrant[i1] \u003d\u003d quadrant[i2]) {\n+                              if (block[i1 + 2] \u003d\u003d block[i2 + 2]) {\n+                                if (quadrant[i1 + 1] \u003d\u003d quadrant[i2 + 1]) {\n+                                  if (block[i1 + 3] \u003d\u003d block[i2 + 3]) {\n+                                    if (quadrant[i1 + 2] \u003d\u003d quadrant[i2 + 2]) {\n+                                      if (block[i1 + 4] \u003d\u003d block[i2 + 4]) {\n+                                        if (quadrant[i1 + 3] \u003d\u003d quadrant[i2 + 3]) {\n+                                          if ((i1 +\u003d 4) \u003e\u003d lastPlus1) {\n+                                            i1 -\u003d lastPlus1;\n+                                          }\n+                                          if ((i2 +\u003d 4) \u003e\u003d lastPlus1) {\n+                                            i2 -\u003d lastPlus1;\n+                                          }\n+                                          workDoneShadow++;\n+                                          continue X;\n+                                        } else if ((quadrant[i1 + 3] \u003e quadrant[i2 + 3])) {\n+                                          continue HAMMER;\n+                                        } else {\n+                                          break HAMMER;\n+                                        }\n+                                      } else if ((block[i1 + 4] \u0026 0xff) \u003e (block[i2 + 4] \u0026 0xff)) {\n+                                        continue HAMMER;\n+                                      } else {\n+                                        break HAMMER;\n+                                      }\n+                                    } else if ((quadrant[i1 + 2] \u003e quadrant[i2 + 2])) {\n+                                      continue HAMMER;\n+                                    } else {\n+                                      break HAMMER;\n+                                    }\n+                                  } else if ((block[i1 + 3] \u0026 0xff) \u003e (block[i2 + 3] \u0026 0xff)) {\n+                                    continue HAMMER;\n+                                  } else {\n+                                    break HAMMER;\n+                                  }\n+                                } else if ((quadrant[i1 + 1] \u003e quadrant[i2 + 1])) {\n+                                  continue HAMMER;\n+                                } else {\n+                                  break HAMMER;\n+                                }\n+                              } else if ((block[i1 + 2] \u0026 0xff) \u003e (block[i2 + 2] \u0026 0xff)) {\n+                                continue HAMMER;\n+                              } else {\n+                                break HAMMER;\n+                              }\n+                            } else if ((quadrant[i1] \u003e quadrant[i2])) {\n+                              continue HAMMER;\n+                            } else {\n+                              break HAMMER;\n+                            }\n+                          } else if ((block[i1 + 1] \u0026 0xff) \u003e (block[i2 + 1] \u0026 0xff)) {\n+                            continue HAMMER;\n+                          } else {\n+                            break HAMMER;\n+                          }\n+\n+                        }\n+                        break HAMMER;\n+                      } // while x \u003e 0\n+                      else {\n+                        if ((block[i1] \u0026 0xff) \u003e (block[i2] \u0026 0xff)) {\n+                          continue HAMMER;\n+                        } else {\n+                          break HAMMER;\n+                        }\n+                      }\n+                    } else if ((block[i1 + 5] \u0026 0xff) \u003e (block[i2 + 5] \u0026 0xff)) {\n+                      continue HAMMER;\n+                    } else {\n+                      break HAMMER;\n+                    }\n+                  } else if ((block[i1 + 4] \u0026 0xff) \u003e (block[i2 + 4] \u0026 0xff)) {\n+                    continue HAMMER;\n+                  } else {\n+                    break HAMMER;\n+                  }\n+                } else if ((block[i1 + 3] \u0026 0xff) \u003e (block[i2 + 3] \u0026 0xff)) {\n+                  continue HAMMER;\n+                } else {\n+                  break HAMMER;\n+                }\n+              } else if ((block[i1 + 2] \u0026 0xff) \u003e (block[i2 + 2] \u0026 0xff)) {\n+                continue HAMMER;\n+              } else {\n+                break HAMMER;\n+              }\n+            } else if ((block[i1 + 1] \u0026 0xff) \u003e (block[i2 + 1] \u0026 0xff)) {\n+              continue HAMMER;\n+            } else {\n+              break HAMMER;\n+            }\n+\n+          } // HAMMER\n+          // end inline mainGTU\n+\n+          fmap[j] \u003d v;\n+        }\n+\n+        if (firstAttemptShadow \u0026\u0026 (i \u003c\u003d hi)\n+            \u0026\u0026 (workDoneShadow \u003e workLimitShadow)) {\n+          break HP;\n+        }\n+      }\n+    }\n+\n+    this.workDone \u003d workDoneShadow;\n+    return firstAttemptShadow \u0026\u0026 (workDoneShadow \u003e workLimitShadow);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean mainSimpleSort(final Data dataShadow, final int lo,\n      final int hi, final int d) {\n    final int bigN \u003d hi - lo + 1;\n    if (bigN \u003c 2) {\n      return this.firstAttempt \u0026\u0026 (this.workDone \u003e this.workLimit);\n    }\n\n    int hp \u003d 0;\n    while (INCS[hp] \u003c bigN) {\n      hp++;\n    }\n\n    final int[] fmap \u003d dataShadow.fmap;\n    final char[] quadrant \u003d dataShadow.quadrant;\n    final byte[] block \u003d dataShadow.block;\n    final int lastShadow \u003d this.last;\n    final int lastPlus1 \u003d lastShadow + 1;\n    final boolean firstAttemptShadow \u003d this.firstAttempt;\n    final int workLimitShadow \u003d this.workLimit;\n    int workDoneShadow \u003d this.workDone;\n\n    // Following block contains unrolled code which could be shortened by\n    // coding it in additional loops.\n\n    HP: while (--hp \u003e\u003d 0) {\n      final int h \u003d INCS[hp];\n      final int mj \u003d lo + h - 1;\n\n      for (int i \u003d lo + h; i \u003c\u003d hi;) {\n        // copy\n        for (int k \u003d 3; (i \u003c\u003d hi) \u0026\u0026 (--k \u003e\u003d 0); i++) {\n          final int v \u003d fmap[i];\n          final int vd \u003d v + d;\n          int j \u003d i;\n\n          // for (int a;\n          // (j \u003e mj) \u0026\u0026 mainGtU((a \u003d fmap[j - h]) + d, vd,\n          // block, quadrant, lastShadow);\n          // j -\u003d h) {\n          // fmap[j] \u003d a;\n          // }\n          //\n          // unrolled version:\n\n          // start inline mainGTU\n          boolean onceRunned \u003d false;\n          int a \u003d 0;\n\n          HAMMER: while (true) {\n            if (onceRunned) {\n              fmap[j] \u003d a;\n              if ((j -\u003d h) \u003c\u003d mj) {\n                break HAMMER;\n              }\n            } else {\n              onceRunned \u003d true;\n            }\n\n            a \u003d fmap[j - h];\n            int i1 \u003d a + d;\n            int i2 \u003d vd;\n\n            // following could be done in a loop, but\n            // unrolled it for performance:\n            if (block[i1 + 1] \u003d\u003d block[i2 + 1]) {\n              if (block[i1 + 2] \u003d\u003d block[i2 + 2]) {\n                if (block[i1 + 3] \u003d\u003d block[i2 + 3]) {\n                  if (block[i1 + 4] \u003d\u003d block[i2 + 4]) {\n                    if (block[i1 + 5] \u003d\u003d block[i2 + 5]) {\n                      if (block[(i1 +\u003d 6)] \u003d\u003d block[(i2 +\u003d 6)]) {\n                        int x \u003d lastShadow;\n                        X: while (x \u003e 0) {\n                          x -\u003d 4;\n\n                          if (block[i1 + 1] \u003d\u003d block[i2 + 1]) {\n                            if (quadrant[i1] \u003d\u003d quadrant[i2]) {\n                              if (block[i1 + 2] \u003d\u003d block[i2 + 2]) {\n                                if (quadrant[i1 + 1] \u003d\u003d quadrant[i2 + 1]) {\n                                  if (block[i1 + 3] \u003d\u003d block[i2 + 3]) {\n                                    if (quadrant[i1 + 2] \u003d\u003d quadrant[i2 + 2]) {\n                                      if (block[i1 + 4] \u003d\u003d block[i2 + 4]) {\n                                        if (quadrant[i1 + 3] \u003d\u003d quadrant[i2 + 3]) {\n                                          if ((i1 +\u003d 4) \u003e\u003d lastPlus1) {\n                                            i1 -\u003d lastPlus1;\n                                          }\n                                          if ((i2 +\u003d 4) \u003e\u003d lastPlus1) {\n                                            i2 -\u003d lastPlus1;\n                                          }\n                                          workDoneShadow++;\n                                          continue X;\n                                        } else if ((quadrant[i1 + 3] \u003e quadrant[i2 + 3])) {\n                                          continue HAMMER;\n                                        } else {\n                                          break HAMMER;\n                                        }\n                                      } else if ((block[i1 + 4] \u0026 0xff) \u003e (block[i2 + 4] \u0026 0xff)) {\n                                        continue HAMMER;\n                                      } else {\n                                        break HAMMER;\n                                      }\n                                    } else if ((quadrant[i1 + 2] \u003e quadrant[i2 + 2])) {\n                                      continue HAMMER;\n                                    } else {\n                                      break HAMMER;\n                                    }\n                                  } else if ((block[i1 + 3] \u0026 0xff) \u003e (block[i2 + 3] \u0026 0xff)) {\n                                    continue HAMMER;\n                                  } else {\n                                    break HAMMER;\n                                  }\n                                } else if ((quadrant[i1 + 1] \u003e quadrant[i2 + 1])) {\n                                  continue HAMMER;\n                                } else {\n                                  break HAMMER;\n                                }\n                              } else if ((block[i1 + 2] \u0026 0xff) \u003e (block[i2 + 2] \u0026 0xff)) {\n                                continue HAMMER;\n                              } else {\n                                break HAMMER;\n                              }\n                            } else if ((quadrant[i1] \u003e quadrant[i2])) {\n                              continue HAMMER;\n                            } else {\n                              break HAMMER;\n                            }\n                          } else if ((block[i1 + 1] \u0026 0xff) \u003e (block[i2 + 1] \u0026 0xff)) {\n                            continue HAMMER;\n                          } else {\n                            break HAMMER;\n                          }\n\n                        }\n                        break HAMMER;\n                      } // while x \u003e 0\n                      else {\n                        if ((block[i1] \u0026 0xff) \u003e (block[i2] \u0026 0xff)) {\n                          continue HAMMER;\n                        } else {\n                          break HAMMER;\n                        }\n                      }\n                    } else if ((block[i1 + 5] \u0026 0xff) \u003e (block[i2 + 5] \u0026 0xff)) {\n                      continue HAMMER;\n                    } else {\n                      break HAMMER;\n                    }\n                  } else if ((block[i1 + 4] \u0026 0xff) \u003e (block[i2 + 4] \u0026 0xff)) {\n                    continue HAMMER;\n                  } else {\n                    break HAMMER;\n                  }\n                } else if ((block[i1 + 3] \u0026 0xff) \u003e (block[i2 + 3] \u0026 0xff)) {\n                  continue HAMMER;\n                } else {\n                  break HAMMER;\n                }\n              } else if ((block[i1 + 2] \u0026 0xff) \u003e (block[i2 + 2] \u0026 0xff)) {\n                continue HAMMER;\n              } else {\n                break HAMMER;\n              }\n            } else if ((block[i1 + 1] \u0026 0xff) \u003e (block[i2 + 1] \u0026 0xff)) {\n              continue HAMMER;\n            } else {\n              break HAMMER;\n            }\n\n          } // HAMMER\n          // end inline mainGTU\n\n          fmap[j] \u003d v;\n        }\n\n        if (firstAttemptShadow \u0026\u0026 (i \u003c\u003d hi)\n            \u0026\u0026 (workDoneShadow \u003e workLimitShadow)) {\n          break HP;\n        }\n      }\n    }\n\n    this.workDone \u003d workDoneShadow;\n    return firstAttemptShadow \u0026\u0026 (workDoneShadow \u003e workLimitShadow);\n  }",
      "path": "src/java/org/apache/hadoop/io/compress/bzip2/CBZip2OutputStream.java"
    }
  }
}