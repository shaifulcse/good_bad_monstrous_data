{
  "origin": "codeshovel",
  "repositoryName": "lucene-solr",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/lucene-solr/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SimplePreAnalyzedParser.java",
  "functionName": "parse",
  "functionId": "parse___reader-Reader__parent-AttributeSource",
  "sourceFilePath": "solr/core/src/java/org/apache/solr/schema/SimplePreAnalyzedParser.java",
  "functionStartLine": 215,
  "functionEndLine": 410,
  "numCommitsSeen": 10,
  "timeTaken": 739,
  "changeHistory": [
    "4a3aba33b5815b94bde2019255e864be5e74cb30"
  ],
  "changeHistoryShort": {
    "4a3aba33b5815b94bde2019255e864be5e74cb30": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4a3aba33b5815b94bde2019255e864be5e74cb30": {
      "type": "Yintroduced",
      "commitMessage": "SOLR-1535 Pre-analyzed field type.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1327982 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/04/12 8:10 AM",
      "commitName": "4a3aba33b5815b94bde2019255e864be5e74cb30",
      "commitAuthor": "Andrzej Bialecki",
      "diff": "@@ -0,0 +1,196 @@\n+  public ParseResult parse(Reader reader, AttributeSource parent) throws IOException {\n+    ParseResult res \u003d new ParseResult();\n+    StringBuilder sb \u003d new StringBuilder();\n+    char[] buf \u003d new char[128];\n+    int cnt;\n+    while ((cnt \u003d reader.read(buf)) \u003e 0) {\n+      sb.append(buf, 0, cnt);\n+    }\n+    String val \u003d sb.toString();\n+    // empty string - accept even without version number\n+    if (val.length() \u003d\u003d 0) {\n+      return res;\n+    }\n+    // first consume the version\n+    int idx \u003d val.indexOf(\u0027 \u0027);\n+    if (idx \u003d\u003d -1) {\n+      throw new IOException(\"Missing VERSION token\");\n+    }\n+    String version \u003d val.substring(0, idx);\n+    if (!VERSION.equals(version)) {\n+      throw new IOException(\"Unknown VERSION \" + version);\n+    }\n+    val \u003d val.substring(idx + 1);\n+    // then consume the optional stored part\n+    int tsStart \u003d 0;\n+    boolean hasStored \u003d false;\n+    StringBuilder storedBuf \u003d new StringBuilder();\n+    if (val.charAt(0) \u003d\u003d \u0027\u003d\u0027) {\n+      hasStored \u003d true;\n+      if (val.length() \u003e 1) {\n+        for (int i \u003d 1; i \u003c val.length(); i++) {\n+          char c \u003d val.charAt(i);\n+          if (c \u003d\u003d \u0027\\\\\u0027) {\n+            if (i \u003c val.length() - 1) {\n+              c \u003d val.charAt(++i);\n+              if (c \u003d\u003d \u0027\u003d\u0027) { // we recognize only \\\u003d escape in the stored part\n+                storedBuf.append(\u0027\u003d\u0027);\n+              } else {\n+                storedBuf.append(\u0027\\\\\u0027);\n+                storedBuf.append(c);\n+                continue;\n+              }\n+            } else {\n+              storedBuf.append(c);\n+              continue;\n+            }\n+          } else if (c \u003d\u003d \u0027\u003d\u0027) {\n+            // end of stored text\n+            tsStart \u003d i + 1;\n+            break;\n+          } else {\n+            storedBuf.append(c);\n+          }\n+        }\n+        if (tsStart \u003d\u003d 0) { // missing end-of-stored marker\n+          throw new IOException(\"Missing end marker of stored part\");\n+        }\n+      } else {\n+        throw new IOException(\"Unexpected end of stored field\");\n+      }\n+    }\n+    if (hasStored) {\n+      res.str \u003d storedBuf.toString();\n+    }\n+    Tok tok \u003d new Tok();\n+    StringBuilder attName \u003d new StringBuilder();\n+    StringBuilder attVal \u003d new StringBuilder();\n+    // parser state\n+    S s \u003d S.UNDEF;\n+    int lastPos \u003d 0;\n+    for (int i \u003d tsStart; i \u003c val.length(); i++) {\n+      char c \u003d val.charAt(i);\n+      if (c \u003d\u003d \u0027 \u0027) {\n+        // collect leftovers\n+        switch (s) {\n+        case VALUE :\n+          if (attVal.length() \u003d\u003d 0) {\n+            throw new IOException(\"Unexpected character \u0027\" + c + \"\u0027 at position \" + i + \" - empty value of attribute.\");\n+          }\n+          if (attName.length() \u003e 0) {\n+            tok.attr.put(attName.toString(), attVal.toString());\n+          }\n+          break;\n+        case NAME: // attr name without a value ?\n+          if (attName.length() \u003e 0) {\n+            throw new IOException(\"Unexpected character \u0027\" + c + \"\u0027 at position \" + i + \" - missing attribute value.\");\n+          } else {\n+            // accept missing att name and value\n+          }\n+          break;\n+        case TOKEN:\n+        case UNDEF:\n+          // do nothing, advance to next token\n+        }\n+        attName.setLength(0);\n+        attVal.setLength(0);\n+        if (!tok.isEmpty() || s \u003d\u003d S.NAME) {\n+          AttributeSource.State state \u003d createState(parent, tok, lastPos);\n+          if (state !\u003d null) res.states.add(state.clone());\n+        }\n+        // reset tok\n+        s \u003d S.UNDEF;\n+        tok.reset();\n+        // skip\n+        lastPos++;\n+        continue;\n+      }\n+      StringBuilder tgt \u003d null;\n+      switch (s) {\n+      case TOKEN:\n+        tgt \u003d tok.token;\n+        break;\n+      case NAME:\n+        tgt \u003d attName;\n+        break;\n+      case VALUE:\n+        tgt \u003d attVal;\n+        break;\n+      case UNDEF:\n+        tgt \u003d tok.token;\n+        s \u003d S.TOKEN;\n+      }\n+      if (c \u003d\u003d \u0027\\\\\u0027) {\n+        if (s \u003d\u003d S.TOKEN) lastPos++;\n+        if (i \u003e\u003d val.length() - 1) { // end\n+          \n+          tgt.append(c);\n+          continue;\n+        } else {\n+          c \u003d val.charAt(++i);\n+          switch (c) {\n+          case \u0027\\\\\u0027 :\n+          case \u0027\u003d\u0027 :\n+          case \u0027,\u0027 :\n+          case \u0027 \u0027 :\n+            tgt.append(c);\n+            break;\n+          case \u0027n\u0027:\n+            tgt.append(\u0027\\n\u0027);\n+            break;\n+          case \u0027r\u0027:\n+            tgt.append(\u0027\\r\u0027);\n+            break;\n+          case \u0027t\u0027:\n+            tgt.append(\u0027\\t\u0027);\n+            break;\n+          default:\n+            tgt.append(\u0027\\\\\u0027);\n+            tgt.append(c);\n+            lastPos++;\n+          }\n+        }\n+      } else {\n+        // state switch\n+        if (c \u003d\u003d \u0027,\u0027) {\n+          if (s \u003d\u003d S.TOKEN) {\n+            s \u003d S.NAME;\n+          } else if (s \u003d\u003d S.VALUE) { // end of value, start of next attr\n+            if (attVal.length() \u003d\u003d 0) {\n+              throw new IOException(\"Unexpected character \u0027\" + c + \"\u0027 at position \" + i + \" - empty value of attribute.\");\n+            }\n+            if (attName.length() \u003e 0 \u0026\u0026 attVal.length() \u003e 0) {\n+              tok.attr.put(attName.toString(), attVal.toString());\n+            }\n+            // reset\n+            attName.setLength(0);\n+            attVal.setLength(0);\n+            s \u003d S.NAME;\n+          } else {\n+            throw new IOException(\"Unexpected character \u0027\" + c + \"\u0027 at position \" + i + \" - missing attribute value.\");\n+          }\n+        } else if (c \u003d\u003d \u0027\u003d\u0027) {\n+          if (s \u003d\u003d S.NAME) {\n+            s \u003d S.VALUE;\n+          } else {\n+            throw new IOException(\"Unexpected character \u0027\" + c + \"\u0027 at position \" + i + \" - empty value of attribute.\");\n+          }\n+        } else {\n+          tgt.append(c);\n+          if (s \u003d\u003d S.TOKEN) lastPos++;\n+        }\n+      }\n+    }\n+    // collect leftovers\n+    if (!tok.isEmpty() || s \u003d\u003d S.NAME || s \u003d\u003d S.VALUE) {\n+      // remaining attrib?\n+      if (s \u003d\u003d S.VALUE) {\n+        if (attName.length() \u003e 0 \u0026\u0026 attVal.length() \u003e 0) {\n+          tok.attr.put(attName.toString(), attVal.toString());\n+        }        \n+      }\n+      AttributeSource.State state \u003d createState(parent, tok, lastPos);\n+      if (state !\u003d null) res.states.add(state.clone());\n+    }\n+    return res;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public ParseResult parse(Reader reader, AttributeSource parent) throws IOException {\n    ParseResult res \u003d new ParseResult();\n    StringBuilder sb \u003d new StringBuilder();\n    char[] buf \u003d new char[128];\n    int cnt;\n    while ((cnt \u003d reader.read(buf)) \u003e 0) {\n      sb.append(buf, 0, cnt);\n    }\n    String val \u003d sb.toString();\n    // empty string - accept even without version number\n    if (val.length() \u003d\u003d 0) {\n      return res;\n    }\n    // first consume the version\n    int idx \u003d val.indexOf(\u0027 \u0027);\n    if (idx \u003d\u003d -1) {\n      throw new IOException(\"Missing VERSION token\");\n    }\n    String version \u003d val.substring(0, idx);\n    if (!VERSION.equals(version)) {\n      throw new IOException(\"Unknown VERSION \" + version);\n    }\n    val \u003d val.substring(idx + 1);\n    // then consume the optional stored part\n    int tsStart \u003d 0;\n    boolean hasStored \u003d false;\n    StringBuilder storedBuf \u003d new StringBuilder();\n    if (val.charAt(0) \u003d\u003d \u0027\u003d\u0027) {\n      hasStored \u003d true;\n      if (val.length() \u003e 1) {\n        for (int i \u003d 1; i \u003c val.length(); i++) {\n          char c \u003d val.charAt(i);\n          if (c \u003d\u003d \u0027\\\\\u0027) {\n            if (i \u003c val.length() - 1) {\n              c \u003d val.charAt(++i);\n              if (c \u003d\u003d \u0027\u003d\u0027) { // we recognize only \\\u003d escape in the stored part\n                storedBuf.append(\u0027\u003d\u0027);\n              } else {\n                storedBuf.append(\u0027\\\\\u0027);\n                storedBuf.append(c);\n                continue;\n              }\n            } else {\n              storedBuf.append(c);\n              continue;\n            }\n          } else if (c \u003d\u003d \u0027\u003d\u0027) {\n            // end of stored text\n            tsStart \u003d i + 1;\n            break;\n          } else {\n            storedBuf.append(c);\n          }\n        }\n        if (tsStart \u003d\u003d 0) { // missing end-of-stored marker\n          throw new IOException(\"Missing end marker of stored part\");\n        }\n      } else {\n        throw new IOException(\"Unexpected end of stored field\");\n      }\n    }\n    if (hasStored) {\n      res.str \u003d storedBuf.toString();\n    }\n    Tok tok \u003d new Tok();\n    StringBuilder attName \u003d new StringBuilder();\n    StringBuilder attVal \u003d new StringBuilder();\n    // parser state\n    S s \u003d S.UNDEF;\n    int lastPos \u003d 0;\n    for (int i \u003d tsStart; i \u003c val.length(); i++) {\n      char c \u003d val.charAt(i);\n      if (c \u003d\u003d \u0027 \u0027) {\n        // collect leftovers\n        switch (s) {\n        case VALUE :\n          if (attVal.length() \u003d\u003d 0) {\n            throw new IOException(\"Unexpected character \u0027\" + c + \"\u0027 at position \" + i + \" - empty value of attribute.\");\n          }\n          if (attName.length() \u003e 0) {\n            tok.attr.put(attName.toString(), attVal.toString());\n          }\n          break;\n        case NAME: // attr name without a value ?\n          if (attName.length() \u003e 0) {\n            throw new IOException(\"Unexpected character \u0027\" + c + \"\u0027 at position \" + i + \" - missing attribute value.\");\n          } else {\n            // accept missing att name and value\n          }\n          break;\n        case TOKEN:\n        case UNDEF:\n          // do nothing, advance to next token\n        }\n        attName.setLength(0);\n        attVal.setLength(0);\n        if (!tok.isEmpty() || s \u003d\u003d S.NAME) {\n          AttributeSource.State state \u003d createState(parent, tok, lastPos);\n          if (state !\u003d null) res.states.add(state.clone());\n        }\n        // reset tok\n        s \u003d S.UNDEF;\n        tok.reset();\n        // skip\n        lastPos++;\n        continue;\n      }\n      StringBuilder tgt \u003d null;\n      switch (s) {\n      case TOKEN:\n        tgt \u003d tok.token;\n        break;\n      case NAME:\n        tgt \u003d attName;\n        break;\n      case VALUE:\n        tgt \u003d attVal;\n        break;\n      case UNDEF:\n        tgt \u003d tok.token;\n        s \u003d S.TOKEN;\n      }\n      if (c \u003d\u003d \u0027\\\\\u0027) {\n        if (s \u003d\u003d S.TOKEN) lastPos++;\n        if (i \u003e\u003d val.length() - 1) { // end\n          \n          tgt.append(c);\n          continue;\n        } else {\n          c \u003d val.charAt(++i);\n          switch (c) {\n          case \u0027\\\\\u0027 :\n          case \u0027\u003d\u0027 :\n          case \u0027,\u0027 :\n          case \u0027 \u0027 :\n            tgt.append(c);\n            break;\n          case \u0027n\u0027:\n            tgt.append(\u0027\\n\u0027);\n            break;\n          case \u0027r\u0027:\n            tgt.append(\u0027\\r\u0027);\n            break;\n          case \u0027t\u0027:\n            tgt.append(\u0027\\t\u0027);\n            break;\n          default:\n            tgt.append(\u0027\\\\\u0027);\n            tgt.append(c);\n            lastPos++;\n          }\n        }\n      } else {\n        // state switch\n        if (c \u003d\u003d \u0027,\u0027) {\n          if (s \u003d\u003d S.TOKEN) {\n            s \u003d S.NAME;\n          } else if (s \u003d\u003d S.VALUE) { // end of value, start of next attr\n            if (attVal.length() \u003d\u003d 0) {\n              throw new IOException(\"Unexpected character \u0027\" + c + \"\u0027 at position \" + i + \" - empty value of attribute.\");\n            }\n            if (attName.length() \u003e 0 \u0026\u0026 attVal.length() \u003e 0) {\n              tok.attr.put(attName.toString(), attVal.toString());\n            }\n            // reset\n            attName.setLength(0);\n            attVal.setLength(0);\n            s \u003d S.NAME;\n          } else {\n            throw new IOException(\"Unexpected character \u0027\" + c + \"\u0027 at position \" + i + \" - missing attribute value.\");\n          }\n        } else if (c \u003d\u003d \u0027\u003d\u0027) {\n          if (s \u003d\u003d S.NAME) {\n            s \u003d S.VALUE;\n          } else {\n            throw new IOException(\"Unexpected character \u0027\" + c + \"\u0027 at position \" + i + \" - empty value of attribute.\");\n          }\n        } else {\n          tgt.append(c);\n          if (s \u003d\u003d S.TOKEN) lastPos++;\n        }\n      }\n    }\n    // collect leftovers\n    if (!tok.isEmpty() || s \u003d\u003d S.NAME || s \u003d\u003d S.VALUE) {\n      // remaining attrib?\n      if (s \u003d\u003d S.VALUE) {\n        if (attName.length() \u003e 0 \u0026\u0026 attVal.length() \u003e 0) {\n          tok.attr.put(attName.toString(), attVal.toString());\n        }        \n      }\n      AttributeSource.State state \u003d createState(parent, tok, lastPos);\n      if (state !\u003d null) res.states.add(state.clone());\n    }\n    return res;\n  }",
      "path": "solr/core/src/java/org/apache/solr/schema/SimplePreAnalyzedParser.java"
    }
  }
}